#!/usr/bin/perl

use 5.030 ; use warnings ; 
use Getopt::Std ; getopts '2:d:m:o:s:t:' , \my%o ; 
use Term::ANSIColor qw [ :constants ] ; $Term::ANSIColor::AUTORESET = 1 ;
use List::Util qw[ min ] ; 
use POSIX qw [ floor ceil ] ;
use Math::Random::MT qw[ rand ] ;
use Time::HiRes qw[ gettimeofday tv_interval ]; 
my $t0 = [gettimeofday] ;

my $seed = exists $o{s} ? srand $o{s} : srand ;
END{ 
  exit if 0 eq ($o{2}//'') ; 
  say STDERR RED BOLD FAINT "Random seed = $seed" ;
  say STDERR RED BOLD FAINT "The elapsed second = " .tv_interval ($t0) ;
}

$o{d} //= 1 ; # 10 ** $o{d} の数が最大
$o{m} //= 3 ; # 何個の異なる数を取り出すか。ただし0より大。
$o{t} //= 200 ; # 各分母で、何回ランダムに試すか? 
$o{o} //= 1 ; 
my $u10 = 10 ** $o{d} ; 
my @f2d ; #  keys %{ $f2d{ $fig } }  == [ denom1, denom2, denom3 .. ]のようになる

# ↑小数点以下$o{d}桁の fig という数の並び(000-999)に対して、次を格納。
# {denom | あるN/denom を小数点以下 $o{d}まで四捨五入した結果 が fig に一致} 

for my $den ( 1 .. $u10 ) {  # den ← denominator
  $SIG{INT} = sub { say STDERR BOLD YELLOW "Denominator = $den" } ;
  print "$den\t" ; # 1. 分母を出力
  # その分母が小数点以下d桁でどんなfigureを生成するかを、次の2行で求める。
  my @figs = () ;
  push @figs , int 0.5 + $u10 * $_ / $den for 1 .. $den - 1 ; ## **1 ;  $_ は 元々$den 

  my %freq ; 
  for my $i ( 0 .. $o{t} - 1 ) { # $o{t}回の反復
    my @cand = & pickR ( \@figs ) ; # ここで$o{m}個(足りない場合は全部)を@figsからランダムに取り出す。
    my $Nth = $o{o} ; 
    if ( @cand ) { 
      my %comm ;#  = map {($_,1)} $f2d [ shift @cand ]  ; ## 
      $comm{$_} = 1 for keys %{ $f2d [ shift @cand ] } ;
      for my $c ( @cand ) { grep { ! exists $f2d[$c]{$_} && delete $comm{$_} } keys %comm } ;
      $Nth += keys %comm ;
    }
    $freq{$Nth} ++ ; # 頻度表に集計である。
    
  }
  #print "${_}\t$freq{$_}\t" for sort { $a <=> $b } keys %freq ; 
  say join "\t" , map { ${_} , $freq{$_} } sort { $a <=> $b } keys %freq ; 
  #- push @{ $f2d [ $_ ] } , $den for @figs ;  ## **2 次の分母に行く前の、重要な処理である。
  $f2d [ $_ ] { $den } = 1 for @figs ; # <-- 変数の使い方は、これが分かりやすい。
}

sub pickR ( $ ){ ## $den-1くらいの長さの配列を@candにコピーは重いので、ダステンフェルドの手法に書き換えたい。
  my @cand = @{ $_[0] } ;
  my @ret ; # = () ; 
  push @ret , splice @cand , rand( scalar @cand ) , 1 for 1 .. min $o{m} , scalar @cand ; 
  return @ret ;
}

exit ;

sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
  use FindBin qw[ $Script ] ;
  $ARGV[1] //= '' ;
  open my $FH , '<' , $0 ;
  while(<$FH>){
    s/\$0/$Script/g ;
    print $_ if $ARGV[1] eq 'opt' ? m/^\ +\-/ : s/^=head1// .. s/^=cut// ;
  }
  close $FH ;
  exit 0 ;
}


=encoding utf8

=head1

 $0 

  オプション: 

  -d N : 1から10**d まで調べることになる。正の整数。(digit)
  -m N : 1〜 10**d の各分母Dに対して、1からD-1の中から取れる限りN個の整数を取り出して、それぞれを分子とする。未指定だと3。(multitude?)
  -t N : 各分子に対して、モンテカルロ法を N 回適用する。未指定だと200(trial)
  -o N : 未指定だと1。「Dに対して、Dを逆算した場合、候補の中からDが何番目に小さな数であるか」の数え方は通常は1始まりだが。0始まりにもできる。(offset)
  -s N : ランダムシードの指定。

  使用例: 
    $0 -d1 # 簡単に。

=cut
